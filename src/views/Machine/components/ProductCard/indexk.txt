import React, { Component, useEffect } from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import { withStyles } from '@material-ui/core';
import { Typography, Divider } from '@material-ui/core';
import {
  AccessTime as AccessTimeIcon,
  GetApp as GetAppIcon
} from '@material-ui/icons';
import { Paper } from 'components';
import styles from './styles';
import Foto from "../../../../assets/machine.png";
import { Link, NavLink } from 'react-router-dom';
import Modal from '@material-ui/core/Modal';
import Button from '@material-ui/core/Button';
import { appSettings } from '../../../../utils/settings';
import { makeStyles } from '@material-ui/core/styles';
import axios from 'axios';
import TextField from '@material-ui/core/TextField';
import FormControl from '@material-ui/core/FormControl';
import InputLabel from '@material-ui/core/InputLabel';
import OutlinedInput from '@material-ui/core/OutlinedInput';
import { HubConnectionBuilder, LogLevel } from '@aspnet/signalr/dist/browser/signalr';

function rand() {
  return Math.round(Math.random() * 20) - 10;
}

function getModalStyle() {
  const top = 50 + rand();
  const left = 50 + rand();

  return {
    top: `${top}%`,
    left: `${left}%`,
    transform: `translate(-${top}%, -${left}%)`,
  };
}

const useStyles = makeStyles(theme => ({
  button: {
    margin: theme.spacing(1),
  },
  input: {
    display: 'none',
  },
}));

const ProductCard = (props) => {

  const [open, setOpen] = React.useState(false);
  const [simOpen, setsimOpen] = React.useState(false);
  const [modalStyle] = React.useState(getModalStyle);
  const [sensoren, setSensoren] = React.useState({
    sensoren: [],
  });
  const [sensorTypes, setSensorenTypes] = React.useState({
    sensorTypes: [],
  });
  const [generatedData, setGeneratedData] = React.useState([]);
  const clx = useStyles();
  const connection = new HubConnectionBuilder()
  .withUrl(`http://localhost:5000/sensors`)
  .configureLogging(LogLevel.Information)
  .build();


  React.useEffect(() => {
    let didCancel = false;
    async function getSensorTypes() {
      try {
        const result = await axios.get(`${appSettings.apiBaseUrl}/devices/${props.id}?includes=Sensors`, {
          headers: {
            "Authorization": "Bearer " + appSettings.token
          }
        });
        const result2 = await axios.get(`${appSettings.apiBaseUrl}/types`, {
          headers: {
            "Authorization": "Bearer " + appSettings.token
          }
        });
        const xyz = result2.data;
        const sensorTypes = xyz.filter(s => s.category === 'SensorDataType');
        const alleSensoren = result.data.sensors;
        if (!didCancel) {
          alleSensoren.map(sensor => {
            setSensoren(sensoren => ({
              sensoren: [...sensoren.sensoren, sensor]
            }));
          });
          sensorTypes.map(sensor => {
            setSensorenTypes(sensorTypes => ({
              sensorTypes: [...sensorTypes.sensorTypes, sensor]
            }));
          })
        }
      } catch (error) {
        if (!didCancel) {
          console.log(error);
        }
      }

    }
    getSensorTypes();
    return () => {
      didCancel = true;
    };
  }, [generatedData]);


  const simOpens = () => {
    setsimOpen(true);
  };

  const simClose = () => {
    setsimOpen(false);
    connectToSocket(null, null, 'stop');
  };

  const handleOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  const [values, setValues] = React.useState({
    hardwareId: ""
  })

  const handleChange = name => event => {
    setValues({ ...values, [name]: event.target.value });
  };

  const connectToSocket = (sensors, simulation, status) => {
  
    if(status === 'stop'){
      connection.stop();
    }

    var newStateArray = [];

    connection.on('Status', (data) => {
      console.log(data);
    });

    connection.on('SensorData', (data) => {
      newStateArray.push(data);
    });

    setGeneratedData({generatedData: newStateArray});

    connection.start()
      .then(() => connection.invoke('SubscribeSensorData', sensors, simulation))
      .catch(() => {
        // console.log(error);
      });
  }

  const submitData = () => {
    simOpens();
    const sensors = [
      {
        "DataType": "Temperature",
        "HardwareId": "5232",
        "MachineNaam": "gers"
      },
      {
        "DataType": "Temperature",
        "HardwareId": "5",
        "MachineNaam": "dja"
      }
    ];

    const simulation = {
      "ProductieStraat": "Teststraat",
      "KlantId": "1",
      "Bovenwaarde": 60,
      "Onderwaarde": 40
    }

    connectToSocket(sensors, simulation, null);
  };


  const { classes, className } = props;
  const rootClassName = classNames(classes.root, className);
  const linkTo = `/productiestraat/${props.id}`;
  console.log(generatedData);
  return (
    <Link>
      <Paper className={rootClassName} onClick={handleOpen}>
        <div className={classes.imageWrapper}>
          <img
            alt="Product"
            className={classes.image}
            src={Foto}
          />
        </div>
        <div className={classes.details}>
          <Typography
            className={classes.title}
            variant="h4"
          >
            {props.title}
          </Typography>
          <Typography
            className={classes.description}
            variant="body1"
          >
            {props.description}
          </Typography>
        </div>
      </Paper>
      <Button variant="contained" className={clx.button} color="primary" onClick={() => submitData()}>
        Simulatie starten
      </Button>
      <Modal
        aria-labelledby="simple-modal-title"
        aria-describedby="simple-modal-description"
        open={open}
        onClose={handleClose}
      >
        <div style={modalStyle} className={classes.paper}>
          <Typography variant="h2" id="modal-title" className={classes.machineTitel}>
            Machine informatie
          </Typography>
          {sensorTypes.sensorTypes.length <= 0 ? "Aan het laden" : ""}
          {sensoren.sensoren.map(({ hardwareId, dataTypeId }) => {
            return (
              <div>
                <div className={classes.sensorveld}>
                  <TextField
                    variant="outlined"
                    required
                    fullWidth
                    label="Sensor naam"
                    value={hardwareId}
                  />
                </div>
                <TextField
                  variant="outlined"
                  required
                  fullWidth
                  label="Sensor type"
                  value={sensorTypes.sensorTypes.filter((sensorType) => sensorType.id === dataTypeId).map(x => x.name)}
                  classes={classes.sensorveld}
                />
              </div>
            );
          })}
        </div>
      </Modal>
      <Modal
        aria-labelledby="simple-modal-title"
        aria-describedby="simple-modal-description"
        open={simOpen}
        onClose={simClose}
      >
        <div style={modalStyle} className={classes.paper}>
          <Typography variant="h2" id="modal-title" className={classes.machineTitel}>
            Gegeneerde data
          </Typography>
          {generatedData.length <= 0  ?
            generatedData.map(gd => {
              return (
                <div>
                  <p>id: {gd.id}</p>
                  <p>value: {gd.value}</p>
                </div>
              );
            })
            :
            <p>Kan geen data simuleren</p>
          }
        </div>
      </Modal>
    </Link>
  );

}

ProductCard.propTypes = {
  className: PropTypes.string,
  classes: PropTypes.object.isRequired,
  product: PropTypes.object.isRequired
};

export default withStyles(styles)(ProductCard);
